<!--
  * Erik Fredericks, 2024
  * Rotating a 3D model of a CircuitPlayground Bluefruit via accelerometer data transferred over Bluetooth.

  * https://dustinpfister.github.io/2023/03/24/threejs-quaternion/
  * https://threejs.org/docs/#manual/en/introduction/Loading-3D-models
  * https://github.com/adafruit/Adafruit_CAD_Parts/blob/main/4333%20Circuit%20Playground%20Bluefruit/Circuit%20Playground%20Bluefruit.stl
  * https://github.com/makerdiary/web-device-cli/blob/master/js/app.js
  * https://physics.stackexchange.com/questions/578359/possible-to-convert-accelerometer-x-y-z-measurements-into-quaternion
-->
<html>

<head>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    /*
    #bt-connect {
      position: absolute;
      left: 10px;
      top: 10px;
    }
    */
  </style>
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';


    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xFFFFFF);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);

    const geometry = new THREE.CylinderGeometry(5, 5, 1, 32);
    //const radius = 0.5;  
    //const detail = 12;  
    //const geometry = new THREE.DodecahedronGeometry( radius, detail );

    //const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
    const material = new THREE.MeshPhongMaterial({
      color: 0xFF00FF,    // pink (can also use a CSS color string here)
      flatShading: false,
      wireframe: true,
    });
    const cube = new THREE.Mesh(geometry, material);
    // cube.eulerOrder = 'YZX';

    scene.add(cube);

    let model = null;
    const loader = new GLTFLoader();
    loader.load('./circuit-playground-bluefruit.glb', function (gltf) {
      model = gltf.scene;
      model.scale.set(0.5, 0.5, 0.5);
      scene.add(model);
    }), undefined, function (error) {
      console.log("Error loading GLTF:", error);
    }

    // added for light-sensitive material
    const color = 0x00FFFF;
    const intensity = 50;
    //const intensity = 1;
    //const light = new THREE.AmbientLight(color, intensity);

    const light2 = new THREE.AmbientLight(0xeeeeee, 50); // light whole scene
    const light = new THREE.PointLight(color, intensity);
    light.position.set(0, 0, 2);
    scene.add(light);
    scene.add(light2);

    camera.position.z = 50;

    const axis = new THREE.Vector3(1, 0, 0);

    let x_accel = 0.0;
    let y_accel = 0.0;
    let z_accel = 0.0;

    let degree = 0;
    const x_axis = new THREE.Vector4(1, 0, 0, 0);
    const y_axis = new THREE.Vector4(0, 1, 0, 0);
    let quaternion = new THREE.Quaternion();

    function animate() {
      requestAnimationFrame(animate);

      // console.log(x_accel, y_accel, z_accel);
      x_accel = document.getElementById('x_accel').innerHTML;
      y_accel = document.getElementById('y_accel').innerHTML;
      z_accel = document.getElementById('z_accel').innerHTML;

      //https://physics.stackexchange.com/questions/578359/possible-to-convert-accelerometer-x-y-z-measurements-into-quaternion
      let roll = Math.atan(y_accel / Math.sqrt(Math.pow(x_accel, 2) + Math.pow(z_accel, 2)));// * (180./Math.PI);
      let pitch = Math.atan(-1.0 * x_accel / Math.sqrt(Math.pow(y_accel, 2) + Math.pow(z_accel, 2)));// * (180./Math.PI);
      // console.log(roll,pitch);

      // quaternion = (Math.cos(roll / 2) * x_axis) + (Math.sin(pitch/2) * y_axis);
      // cube.applyQuaternion(quaternion);


      // const a  = new THREE.Euler(x_accel, y_accel, z_accel, 'XYZ');
      // cube.rotation.set(a);

      // cube.quaternion.setFromAxisAngle(axis.normalize(), THREE.MathUtils.degToRad(degree));
      // degree++;

      //[-61.4407, 68.3738] [-13.6748, 69.1783] [-65.4244, 33.3634]
      cube.rotation.x = roll;//p5map(x_accel, -70, 70, 0, 2.0*Math.PI);
      cube.rotation.z = -pitch;//p5map(y_accel, -15, 70, 0, 2.0*Math.PI);
      if (model != null) {
        model.rotation.x = roll;//p5map(x_accel, -70, 70, 0, 2.0*Math.PI);
        model.rotation.z = -pitch;//p5map(y_accel, -15, 70, 0, 2.0*Math.PI);
      }


      // cube.rotation.x = roll;//THREE.MathUtils.degToRad(roll);//y_accel;
      // cube.rotation.y = pitch;//THREE.MathUtils.degToRad(pitch);//x_accel;
      // cube.rotation.z = z_accel;

      // cube.rotation.x += 0.01;
      // cube.rotation.y += 0.01;

      renderer.render(scene, camera);
    }
    animate();
  </script>
  <script>
    const MTU = 20;
    let connected = false;
    let bleDevice;
    let bleServer;
    let nusService;
    let rxCharacteristic;
    let txCharacteristic;

    const bleNusServiceUUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    const bleNusCharRXUUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
    const bleNusCharTXUUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

    function connectionToggle() {
      if (connected) disconnect();
      else connect();
    }

    function setConnButtonState(enabled) {
      let btn = document.getElementById('bt-connect');
      if (enabled) btn.innerHTML = 'disconnect';
      else btn.innerHTML = 'connect';
    }

    function connect() {
      if (!navigator.bluetooth) {
        console.log('WebBluetooth API is not available.\r\n' +
          'Please make sure the Web Bluetooth flag is enabled.');
        return;
      }

      console.log('Requesting Bluetooth Device...');
      navigator.bluetooth.requestDevice({
        //filters: [{services: []}]
        optionalServices: [bleNusServiceUUID],
        acceptAllDevices: true
      })
        .then(device => {
          bleDevice = device;
          console.log('Found ' + device.name);
          console.log('Connecting to GATT Server...');
          bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
          return device.gatt.connect();
        })
        .then(server => {
          console.log('Locate NUS service');
          return server.getPrimaryService(bleNusServiceUUID);
        }).then(service => {
          nusService = service;
          console.log('Found NUS service: ' + service.uuid);
        })
        .then(() => {
          console.log('Locate RX characteristic');
          return nusService.getCharacteristic(bleNusCharRXUUID);
        })
        .then(characteristic => {
          rxCharacteristic = characteristic;
          console.log('Found RX characteristic');
        })
        .then(() => {
          console.log('Locate TX characteristic');
          return nusService.getCharacteristic(bleNusCharTXUUID);
        })
        .then(characteristic => {
          txCharacteristic = characteristic;
          console.log('Found TX characteristic');
        })
        .then(() => {
          console.log('Enable notifications');
          return txCharacteristic.startNotifications();
        })
        .then(() => {
          console.log('Notifications started');
          txCharacteristic.addEventListener('characteristicvaluechanged',
            handleNotifications);
          connected = true;
          // window.term_.io.println('\r\n' + bleDevice.name + ' Connected.');
          // nusSendString('\r');
          setConnButtonState(true);
        })
        .catch(error => {
          console.log('' + error);
          // window.term_.io.println('' + error);
          // if (bleDevice && bleDevice.gatt.connected) {
          //   bleDevice.gatt.disconnect();
          // }
        });
    }

    function disconnect() {
      if (!bleDevice) {
        console.log('No Bluetooth Device connected...');
        return;
      }
      console.log('Disconnecting from Bluetooth Device...');
      if (bleDevice.gatt.connected) {
        bleDevice.gatt.disconnect();
        connected = false;
        setConnButtonState(false);
        console.log('Bluetooth Device connected: ' + bleDevice.gatt.connected);
      } else {
        console.log('> Bluetooth Device is already disconnected');
      }
    }

    function onDisconnected() {
      connected = false;
      setConnButtonState(false);
    }

    function handleNotifications(event) {
      let value = event.target.value;
      // Convert raw data bytes to character values and use these to 
      // construct a string.
      let str = "";
      for (let i = 0; i < value.byteLength; i++) {
        str += String.fromCharCode(value.getUint8(i));
      }

      if (str.indexOf(':') > -1) {
        let splitstr = str.split(':');
        if (splitstr.length > 1) {
          let val = splitstr[1];

          if (splitstr[0] == "x")
            document.getElementById('x_accel').innerHTML = val;
          else if (splitstr[0] == "y")
            document.getElementById('y_accel').innerHTML = val;
          else if (splitstr[0] == "z")
            document.getElementById('z_accel').innerHTML = val;


          // console.log(val, splitstr);
        }
      }

      // console.log(`notification ${str}`);

    }

  </script>
</head>

<body>
  <button id="bt-connect" onclick="connect()">connect</button>
  <span id="x_accel">0.0</span>
  <span id="y_accel">0.0</span>
  <span id="z_accel">0.0</span>
</body>

</html>